#!/usr/bin/env python
"""
Exemplo A2A intermediário com integração de API externa.

Este exemplo demonstra como integrar um agente A2A com a API OpenWeatherMap
para fornecer dados meteorológicos reais.
"""

import os
import sys
import json
import asyncio
import logging
from datetime import datetime, timezone
from typing import Dict, List, Optional, Any, Union

# Adicionar o caminho raiz do projeto ao PYTHONPATH
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "../../..")))

from fastapi import FastAPI, HTTPException, Request, Response
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
import aiohttp

# Configuração da API OpenWeatherMap
OPENWEATHER_API_KEY = os.getenv("OPENWEATHER_API_KEY", "sua_chave_aqui")
OPENWEATHER_CURRENT_URL = "https://api.openweathermap.org/data/2.5/weather"
OPENWEATHER_FORECAST_URL = "https://api.openweathermap.org/data/2.5/forecast"

# A2A protocol type definitions
class AgentCapabilities:
    """Agent capabilities definition."""
    def __init__(self, streaming: bool = False, push_notifications: bool = False):
        self.streaming = streaming
        self.push_notifications = push_notifications
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "streaming": self.streaming,
            "pushNotifications": self.push_notifications
        }

class AgentSkill:
    """Agent skill definition."""
    def __init__(self, id: str, name: str, description: str):
        self.id = id
        self.name = name
        self.description = description
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description
        }

class AgentCard:
    """Agent card definition containing metadata about the agent."""
    def __init__(
        self,
        name: str,
        description: str,
        url: str,
        version: str,
        capabilities: AgentCapabilities,
        skills: List[AgentSkill]
    ):
        self.name = name
        self.description = description
        self.url = url
        self.version = version
        self.capabilities = capabilities
        self.skills = skills
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "description": self.description,
            "url": self.url,
            "version": self.version,
            "capabilities": self.capabilities.to_dict(),
            "skills": [skill.to_dict() for skill in self.skills]
        }

class TextPart:
    """Text message part."""
    def __init__(self, text: str):
        self.text = text
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "type": "text",
            "text": self.text
        }

class DataPart:
    """Structured data message part."""
    def __init__(self, data: Dict[str, Any]):
        self.data = data
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "type": "data",
            "data": self.data
        }

class Message:
    """Message with one or more parts."""
    def __init__(self, role: str, parts: List[Union[TextPart, DataPart]]):
        self.role = role
        self.parts = parts
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "role": self.role,
            "parts": [part.to_dict() for part in self.parts]
        }

class Artifact:
    """Artifact generated by an agent."""
    def __init__(self, name: str, description: str, parts: List[Union[TextPart, DataPart]]):
        self.name = name
        self.description = description
        self.parts = parts
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "description": self.description,
            "parts": [part.to_dict() for part in self.parts]
        }

class TaskStatus:
    """Task status information."""
    def __init__(self, state: str, message: Optional[Message] = None, timestamp: Optional[str] = None):
        self.state = state
        self.message = message
        self.timestamp = timestamp or datetime.now(timezone.utc).isoformat()
    
    def to_dict(self) -> Dict[str, Any]:
        result = {
            "state": self.state,
            "timestamp": self.timestamp
        }
        if self.message:
            result["message"] = self.message.to_dict()
        return result

class Task:
    """Task object representing a unit of work."""
    def __init__(
        self, 
        id: str, 
        session_id: Optional[str] = None, 
        status: Optional[TaskStatus] = None,
        artifacts: Optional[List[Artifact]] = None
    ):
        self.id = id
        self.session_id = session_id
        self.status = status
        self.artifacts = artifacts or []
    
    def to_dict(self) -> Dict[str, Any]:
        result = {
            "id": self.id
        }
        if self.session_id:
            result["sessionId"] = self.session_id
        if self.status:
            result["status"] = self.status.to_dict()
        if self.artifacts:
            result["artifacts"] = [artifact.to_dict() for artifact in self.artifacts]
        return result

# Task state constants
class TaskState:
    """Task state constants."""
    SUBMITTED = "submitted"
    WORKING = "working"
    INPUT_REQUIRED = "input_required"
    COMPLETED = "completed"
    FAILED = "failed"

# In-memory task storage
tasks: Dict[str, Task] = {}

# Create a FastAPI application
app = FastAPI()

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Define our agent card
agent_card = AgentCard(
    name="Assistente Meteorológico API",
    description="Fornece informações sobre clima em tempo real usando a API OpenWeatherMap",
    url="http://localhost:8000",
    version="1.0.0",
    capabilities=AgentCapabilities(
        streaming=True,
        push_notifications=False
    ),
    skills=[
        AgentSkill(
            id="previsao_atual",
            name="Previsão Atual",
            description="Fornece dados meteorológicos atuais para qualquer cidade do mundo"
        ),
        AgentSkill(
            id="previsao_5dias",
            name="Previsão de 5 Dias",
            description="Fornece previsão meteorológica para os próximos 5 dias"
        ),
        AgentSkill(
            id="detalhes_climaticos",
            name="Detalhes Climáticos",
            description="Fornece detalhes sobre umidade, vento, pressão e outros dados climáticos"
        )
    ]
)

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# API Integration Functions
async def get_current_weather(city: str) -> Dict[str, Any]:
    """Consulta a API OpenWeatherMap para obter dados meteorológicos atuais."""
    params = {
        "q": city,
        "appid": OPENWEATHER_API_KEY,
        "units": "metric",
        "lang": "pt_br"
    }
    
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(OPENWEATHER_CURRENT_URL, params=params) as response:
                if response.status == 200:
                    data = await response.json()
                    return {
                        "status": "success",
                        "city": data["name"],
                        "country": data["sys"]["country"],
                        "temperature": data["main"]["temp"],
                        "feels_like": data["main"]["feels_like"],
                        "condition": data["weather"][0]["description"],
                        "condition_id": data["weather"][0]["id"],
                        "humidity": data["main"]["humidity"],
                        "pressure": data["main"]["pressure"],
                        "wind_speed": data["wind"]["speed"],
                        "wind_direction": data["wind"]["deg"],
                        "clouds": data["clouds"]["all"],
                        "timestamp": datetime.fromtimestamp(data["dt"]).isoformat()
                    }
                else:
                    return {
                        "status": "error",
                        "message": f"Erro ao consultar clima: {response.status}",
                        "details": await response.text()
                    }
    except Exception as e:
        logger.error(f"Erro ao consultar clima para {city}: {str(e)}")
        return {
            "status": "error",
            "message": f"Erro ao consultar clima: {str(e)}"
        }

async def get_forecast(city: str, days: int = 5) -> Dict[str, Any]:
    """Consulta a API OpenWeatherMap para obter previsão meteorológica."""
    params = {
        "q": city,
        "appid": OPENWEATHER_API_KEY,
        "units": "metric",
        "lang": "pt_br",
        "cnt": min(days * 8, 40)  # 8 intervalos de 3 horas por dia, máximo 5 dias (40 intervalos)
    }
    
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(OPENWEATHER_FORECAST_URL, params=params) as response:
                if response.status == 200:
                    data = await response.json()
                    
                    # Processar os dados de previsão
                    forecast_items = []
                    for item in data["list"]:
                        forecast_items.append({
                            "timestamp": datetime.fromtimestamp(item["dt"]).isoformat(),
                            "temperature": item["main"]["temp"],
                            "feels_like": item["main"]["feels_like"],
                            "condition": item["weather"][0]["description"],
                            "condition_id": item["weather"][0]["id"],
                            "humidity": item["main"]["humidity"],
                            "wind_speed": item["wind"]["speed"]
                        })
                    
                    return {
                        "status": "success",
                        "city": data["city"]["name"],
                        "country": data["city"]["country"],
                        "forecast": forecast_items
                    }
                else:
                    return {
                        "status": "error",
                        "message": f"Erro ao consultar previsão: {response.status}",
                        "details": await response.text()
                    }
    except Exception as e:
        logger.error(f"Erro ao consultar previsão para {city}: {str(e)}")
        return {
            "status": "error",
            "message": f"Erro ao consultar previsão: {str(e)}"
        }

# Define agent card endpoint
@app.get("/.well-known/agent.json")
async def get_agent_card():
    """Returns the agent card in the A2A protocol format."""
    return agent_card.to_dict()

# Task creation endpoint
@app.post("/tasks")
async def create_task(task_data: Dict[str, Any]):
    """Creates a new task."""
    task_id = task_data.get("id")
    if not task_id:
        raise HTTPException(status_code=400, detail="Task ID is required")
    
    session_id = task_data.get("sessionId")
    
    # Create a new task with submitted status
    task = Task(
        id=task_id,
        session_id=session_id,
        status=TaskStatus(
            state=TaskState.SUBMITTED,
            timestamp=datetime.now(timezone.utc).isoformat()
        )
    )
    
    # Store the task
    tasks[task_id] = task
    
    return task.to_dict()

# Send message to a task
@app.post("/tasks/{task_id}/send")
async def send_message(task_id: str, request: Request):
    """Sends a message to a task."""
    # Check if task exists
    if task_id not in tasks:
        raise HTTPException(status_code=404, detail=f"Task {task_id} not found")
    
    # Get the message from request
    message_data = await request.json()
    
    # Process the message
    task = await process_message(task_id, message_data)
    
    return task.to_dict()

# Get task status
@app.get("/tasks/{task_id}")
async def get_task(task_id: str):
    """Gets the current state of a task."""
    if task_id not in tasks:
        raise HTTPException(status_code=404, detail=f"Task {task_id} not found")
    
    return tasks[task_id].to_dict()

# Extract city from message text
def extract_city(text: str) -> Optional[str]:
    """Extract city name from message text."""
    if "tempo em " in text.lower():
        # Extract city after "tempo em " and before ? or end of string
        parts = text.lower().split("tempo em ")
        if len(parts) > 1:
            city_part = parts[1].split("?")[0].strip()
            if city_part:
                return city_part.title()  # Convert to title case
    
    if "previsão para " in text.lower():
        parts = text.lower().split("previsão para ")
        if len(parts) > 1:
            city_part = parts[1].split("?")[0].strip()
            if city_part:
                return city_part.title()
    
    if "clima em " in text.lower():
        parts = text.lower().split("clima em ")
        if len(parts) > 1:
            city_part = parts[1].split("?")[0].strip()
            if city_part:
                return city_part.title()
    
    return None

# Check if message asks for forecast
def is_forecast_request(text: str) -> bool:
    """Check if the message is asking for a forecast."""
    forecast_terms = [
        "previsão", "próximos dias", "amanhã", "semana",
        "forecast", "próximos", "dias", "previsao"
    ]
    
    return any(term in text.lower() for term in forecast_terms)

async def process_message(task_id: str, message_data: Dict[str, Any]) -> Task:
    """Process a message and update the task."""
    # Get the existing task
    task = tasks[task_id]
    
    # Update task status to working
    task.status = TaskStatus(
        state=TaskState.WORKING,
        timestamp=datetime.now(timezone.utc).isoformat()
    )
    
    # Extract message text
    text = ""
    if "parts" in message_data and len(message_data["parts"]) > 0:
        part = message_data["parts"][0]
        if part.get("type") == "text":
            text = part.get("text", "")
    
    # Check for current task state
    if task.status and task.status.state == TaskState.INPUT_REQUIRED:
        # User is responding to a previous request for input
        city = text.strip()
        
        # Retrieve weather data for the city
        weather_data = await get_current_weather(city)
        
        if weather_data["status"] == "success":
            # Create response
            response_parts = []
            
            # Text response
            weather_text = (
                f"Em {weather_data['city']}, {weather_data['country']}: {weather_data['condition']}.\n"
                f"Temperatura atual: {weather_data['temperature']}°C "
                f"(sensação térmica de {weather_data['feels_like']}°C).\n"
                f"Umidade: {weather_data['humidity']}%, "
                f"Vento: {weather_data['wind_speed']} m/s."
            )
            response_parts.append(TextPart(text=weather_text))
            
            # Data part
            response_parts.append(DataPart(data=weather_data))
            
            # Create response message
            response_message = Message(
                role="agent",
                parts=response_parts
            )
            
            # Create weather data artifact
            weather_artifact = Artifact(
                name="dados_climaticos",
                description=f"Dados climáticos para {weather_data['city']}",
                parts=[DataPart(data=weather_data)]
            )
            
            # Update task with completed status, response, and artifact
            task.status = TaskStatus(
                state=TaskState.COMPLETED,
                message=response_message,
                timestamp=datetime.now(timezone.utc).isoformat()
            )
            task.artifacts = [weather_artifact]
        else:
            # Error response
            response_message = Message(
                role="agent",
                parts=[TextPart(text=f"Não consegui obter informações climáticas para '{city}'. {weather_data['message']}")]
            )
            
            # Update task with error
            task.status = TaskStatus(
                state=TaskState.FAILED,
                message=response_message,
                timestamp=datetime.now(timezone.utc).isoformat()
            )
    else:
        # Regular message processing
        city = extract_city(text)
        
        if not city:
            # No city found, ask the user which city they're interested in
            response_message = Message(
                role="agent",
                parts=[TextPart(text="Para qual cidade você gostaria de saber a previsão do tempo?")]
            )
            
            # Update task to request input
            task.status = TaskStatus(
                state=TaskState.INPUT_REQUIRED,
                message=response_message,
                timestamp=datetime.now(timezone.utc).isoformat()
            )
        else:
            # City found, check if forecast or current weather is requested
            if is_forecast_request(text):
                # Get forecast data
                forecast_data = await get_forecast(city)
                
                if forecast_data["status"] == "success":
                    # Create text summary of forecast
                    forecast_text = f"Previsão para {forecast_data['city']}, {forecast_data['country']}:\n\n"
                    
                    # Group forecast by day
                    days = {}
                    for item in forecast_data["forecast"]:
                        day = item["timestamp"].split("T")[0]
                        if day not in days:
                            days[day] = []
                        days[day].append(item)
                    
                    # Summarize each day
                    for day, items in days.items():
                        day_date = datetime.fromisoformat(day).strftime("%d/%m/%Y")
                        temps = [item["temperature"] for item in items]
                        conditions = [item["condition"] for item in items]
                        
                        # Find most common condition
                        most_common = max(set(conditions), key=conditions.count)
                        
                        forecast_text += (
                            f"- {day_date}: {most_common}, "
                            f"mín {min(temps):.1f}°C, máx {max(temps):.1f}°C\n"
                        )
                    
                    # Create response
                    response_parts = [
                        TextPart(text=forecast_text),
                        DataPart(data=forecast_data)
                    ]
                    
                    response_message = Message(
                        role="agent",
                        parts=response_parts
                    )
                    
                    # Create forecast artifact
                    forecast_artifact = Artifact(
                        name="previsao",
                        description=f"Previsão de 5 dias para {forecast_data['city']}",
                        parts=[DataPart(data=forecast_data)]
                    )
                    
                    # Update task
                    task.status = TaskStatus(
                        state=TaskState.COMPLETED,
                        message=response_message,
                        timestamp=datetime.now(timezone.utc).isoformat()
                    )
                    task.artifacts = [forecast_artifact]
                else:
                    # Error response
                    response_message = Message(
                        role="agent",
                        parts=[TextPart(text=f"Não consegui obter a previsão para '{city}'. {forecast_data['message']}")]
                    )
                    
                    task.status = TaskStatus(
                        state=TaskState.FAILED,
                        message=response_message,
                        timestamp=datetime.now(timezone.utc).isoformat()
                    )
            else:
                # Get current weather
                weather_data = await get_current_weather(city)
                
                if weather_data["status"] == "success":
                    # Create response
                    weather_text = (
                        f"Em {weather_data['city']}, {weather_data['country']}: {weather_data['condition']}.\n"
                        f"Temperatura atual: {weather_data['temperature']}°C "
                        f"(sensação térmica de {weather_data['feels_like']}°C).\n"
                        f"Umidade: {weather_data['humidity']}%, "
                        f"Vento: {weather_data['wind_speed']} m/s."
                    )
                    
                    response_message = Message(
                        role="agent",
                        parts=[
                            TextPart(text=weather_text),
                            DataPart(data=weather_data)
                        ]
                    )
                    
                    # Create weather data artifact
                    weather_artifact = Artifact(
                        name="dados_climaticos",
                        description=f"Dados climáticos para {weather_data['city']}",
                        parts=[DataPart(data=weather_data)]
                    )
                    
                    # Update task
                    task.status = TaskStatus(
                        state=TaskState.COMPLETED,
                        message=response_message,
                        timestamp=datetime.now(timezone.utc).isoformat()
                    )
                    task.artifacts = [weather_artifact]
                else:
                    # Error response
                    response_message = Message(
                        role="agent",
                        parts=[TextPart(text=f"Não consegui obter informações climáticas para '{city}'. {weather_data['message']}")]
                    )
                    
                    task.status = TaskStatus(
                        state=TaskState.FAILED,
                        message=response_message,
                        timestamp=datetime.now(timezone.utc).isoformat()
                    )
    
    # Store updated task
    tasks[task_id] = task
    
    return task

if __name__ == "__main__":
    logger.info("Iniciando servidor A2A com integração API")
    uvicorn.run(app, host="0.0.0.0", port=8000) 